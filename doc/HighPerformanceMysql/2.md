# Schema与数据类型优化

### 数据类型选择原则

- 尽量选最小的：选择不会超过范围的最小类型
- 尽量选择简单的：内建类型（date，time，datatime等）比字符串简单，需要更少的CPU周期
- 避免用NULL（影响不大）：可为NULL的列建索引，索引统计更为复杂。InnoDB使用单独的位存储NULL值，对稀疏数据有很好的空间效率。

### 数据类型

#### 整数类型：-2^(N-1)到2^(N-1)-1,N是存储空间的位数，下面类型分别对应位数

- TINYINT：8
- SMALLINT：16
- MEDIUMINT：24
- INT：32
- BIGINT：64（整数计算常用）
- UNSIGNED：上面类型的UNSIGNED属性，将取消负数范围，正数范围翻倍
  - TINYINT为-128~127，UNSIGNED TINYINT为0~255

#### 实数类型：可以存储小数，也可以用DECIMAL存储比BIGINT大的整数

- DECIMAL：存储精确小数，对小数精确计算时使用（计算代价高）。数据量大，考虑用BIGINT*倍数代替
- DOUBLE：Mysql选用作为内部浮点数计算类型
- FLOAT：计算不精确

#### 字符串类型

- VARCHAR：存储长字符串（变长）
  - 有1，2个字节记录字符串长度信息
  - VARCHAR是变长的，UPDATE时，行占空间可能变长：InnoDB通过分裂页使行可以放入列内
  - VARCHAR定义需要的空间，防止MySQL分配过多的固定内存。
  - InnoDB会把过长的VARCHAR存储为BLOB
- CHAR：存储短字符串（定长）
  - 适合存储密码DM5值，布尔值
  - 存储上更有效率，连续定长空间不易产生碎片
  - 需要一个字节记录字符串长度
  - CHAR存储值时，会自动删除末尾空格
- BINARY和VARBINARY：二进制字符串
  - 跟字符串相似，存储时采用字节码（非字符）D
  - 填充采用\0（零字节），非空格
  - 比较字符串时按每个字节进行比较，速度更快
- BLOB和TEXT：BLOB采用二进制存储，TEXT采用字符串存储
  - 当BLOB和TEXT值太大时，InnoDB会使用外部存储区域进行存储，行内存储1~4个字节的指针
  - BLOB和TEXT的排序，只是采用前面一小部分字符。通过以下调整字符截取
    - max_sort_length配置
    - ORDER BY SUSTRING(column， length)
- ENUM：使用枚举代替字符串，存储的将是键的值

#### 日期和时间类型

- DATETIME
  - 格式为YYYY-MM-DD HH:MM:SS
  - 8个字节存储
  - 时间范围：1001~9999
- TIMESTAMP
  - 4个字节存储
  - 时间范围：1970~2038
  - 时间戳转日期：FROM_UNIXTIME()函数
  - 日期转时间戳：UNIX_TIMESTAMP()函数
  - 显示的时间依赖于服务器的时区设置
  - 如果存储的时间单位小于秒，可以使用DOUBLE字段存储秒之后的小数部分

#### 其他少用

位数据类型

- BIT
- SET

选择标识符

### 范式和反范式

- 特点

  - 开发中范式和反范式一般根据场景采用混用模式，实验室才会完全范式或完全反范式。

- 三范式的定义

  - 一范式

    - 每一列的值不可分割

  - 二范式

    - 每列非主键字段都可以和主键组成唯一标识

    - 不遵从第二范式可能导致

      ![img](img/4.png)  

  - 三范式

    - 数据表A不包含其他表的非主键信息

- 范式的优点和缺点

  - 优点
    - 很少或没有重复数据，更新操作比反范式快
    - 少有DISTINCT和GROUP BY操作，直接查单表即可
  - 缺点
    - 查询数据需要进行多张表的关联

- 反范式的优点和缺点

  - 优点
    - 数据都在一张表上，避免关联查询
  - 缺点
    - 一张表字段过多，修改成本高

### 缓存表和汇总表

- 缓存表
  - 存储其他查询速度较慢的数据
- 汇总表
  - 保存分组查询之后的数据

### 加快ALERT TABLE操作的速度

（使用时再做记录）